<html>
  <head>
    <title>Typing Speed Meter</title>
    <style>

      /* Configuration */

      #configurationPanel {
          border: 0.5em ridge #c8c8c8;
          padding: 0.75em;
      }

      #configurationPanel div {
          margin-bottom: 1em;
      }

      #configurationPanel span {
          display: block;
      }

      /* Game Panel */

      #gamePanel {
          border: 0.5em ridge #c8c8c8;
          padding: 1em;
      }

      /* Text Viewer */

      #textView {
          border: 1px solid #c8c8c8;
          overflow: clip;
          padding: 0.2em;
          white-space: nowrap;
      }

      #textView .word {
          margin-right: 5px;
          padding: 1px;
      }

      #textView .word.first {
          border: 2px solid red;
          font-weight: bold;
      }

      /* Full typed text */

      #fullTypedText {
          background-color: #ffffc8;
          display: flex;
          flex-flow: wrap;
      }

      #fullTypedText span.typed-word {
          color: blue;
          margin-right: 0.4em;
      }

      #fullTypedText span.not-accepted {
          color: red;
          font-weight: bold;
      }

      #fullTypedText span.inaccurate {
          color: red;
      }

    </style>
  </head>
  <body>
    <h1>Typing Speed Meter</h1>
    <div id="configurationPanel">
      <div>
        <span>Mode:</span>
        <select id="modeSelect">
          <option value="followtext">Follow text</option>
          <option value="freetyping">Free typing</option>
        </select>
      </div>
      <div>
        <span>Text:</span>
        <select id="textSelect">
          <!-- <option value="loremipsum1">Lorem Ipsum 1</option> -->
        </select>
      </div>
      <div>
        <span>Minimum accuracy:</span>
        <select id="minimumAccuracySelect">
          <option value="100">Full-match only</option>
          <option value="85">85%</option>
        </select>
      </div>
      <div>
        <span><label><input type="checkbox" id="chkCaseSensitive" /> Case-sensitive</label></span>
      </div>
      <div>
        <span><label><input type="checkbox" id="chkPunctuation" /> Show punctuation</label></span>
      </div>
      <div>
        <span><label><input type="checkbox" id="chkRemoveSpecialChars" /> Remove special characters</label></span>
      </div>
      <div>
        <input type="button" id="gameStartButton" value="START! (CTRL+1)" />
      </div>
    </div>
    <div id="gamePanel">
      <div id="textPanel">
        <span>Text:</span>
        <div id="textView"><span>&nbsp;</span></div>
      </div>
      <hr />
      <div id="typingPanel">
        <div><span>Type here:</span></div>
        <input type="text" id="typedText" />
        <input type="button" id="finishButton" value="FINISH (CTRL+2)" />
      </div>
      <hr />
      <div id="resultsPanel">
        <div><span>Results:</span></div>
        <div><span>Speed (WPM):</span><span id="wpmSpeedResult">&nbsp;</span></div>
        <div><span>Average Accuracy:</span><span id="avgAccuracyResult">&nbsp/</span></div>
        <div><span>Typed text:</span></div>
        <div><div id="fullTypedText">&nbsp;</div></div>
      </div>
    </div>
    <script language="javascript">

      class ConfigurationController {

        eventHandlers = [];

        constructor(
          modeSelect, textSelect, minimumAccuracySelect, chkCaseSensitive, chkPunctuation,
          chkRemoveSpecialChars, gameStartButton, textList,
        ) {
          this.modeSelect = modeSelect;
          this.textSelect = textSelect;
          this.minimumAccuracySelect = minimumAccuracySelect;
          this.chkCaseSensitive = chkCaseSensitive;
          this.chkPunctuation = chkPunctuation;
          this.chkRemoveSpecialChars = chkRemoveSpecialChars;
          this.gameStartButton = gameStartButton;
          this.textList = textList;
          gameStartButton.addEventListener('click', (e) => {
            this.notifyListeners('configurationready', {config: this.getConfig()});
          });
          this.loadAvailableTexts()
        }

        addEventListener(eventName, eventHandler) {
          if (eventName !== 'configurationready') return;
          this.eventHandlers.push({eventName, eventHandler});
        }

        notifyListeners(eventName, e) {
          this.eventHandlers
            .filter(eh => eh.eventName === eventName)
            .forEach(eh => eh.eventHandler(e));
        }

        getConfig() {
          return {
            textKey: this.textSelect.value,
            minimumAccuracy: this.minimumAccuracySelect.value / 100,
            caseSensitive: this.chkCaseSensitive.checked,
            requirePunctuation: this.chkPunctuation.checked,
            removeSpecialChars: this.chkRemoveSpecialChars.checked,
          };
        }

        loadAvailableTexts() {
          this.textList.forEach(tn => {
            const op = document.createElement('option');
            op.value = tn.key;
            op.innerHTML = tn.name;
            textSelect.appendChild(op);
          });
        }
      }

      class EventDriver {

        eventHandlers = [];

        addEventListener(eventName, eventHandler) {
          this.eventHandlers.push({eventName, eventHandler});
        }

        notifyListeners(eventName, eventArgs) {
          this.eventHandlers
            .filter(el => el.eventName === eventName)
            .forEach(el => el.eventHandler(eventArgs));
        }

      }

      class TextBarController extends EventDriver {

        activeWord;
        config;
        textView;
        statusReporter;
        statusTimerHandler;

        constructor(textView, statusReporter) {
          super();
          this.textView = textView;
          this.statusReporter = statusReporter;
        }

        start() {
          this.statusReporter.start();
          // TODO start timer for periodical result reports
          this.statusTimerHandler = window.setInterval(() => {
            const status = this.statusReporter.getStatus();
            this.notifyListeners('results', {results: status});
          }, 1500);
        }

        reset() {
          this.statusTimerHandler.cancelInterval();
          this.statusReporter.reset();
        }

        displayText(text, config) {
          if (!text) throw new Error('Text is undefined');
          if (!config) throw new Error('Config is undefined');
          this.config = config;
          this.textView.innerHTML = '';
          const words = text.split(' ');
          if (words.length === 0) return;
          const firstWordEl = document.createElement('span');
          firstWordEl.setAttribute('class', 'word first');
          firstWordEl.innerHTML = words[0];
          this.activeWord = words[0];
          this.textView.appendChild(firstWordEl);
          for (let i = 1; i < words.length; ++i) {
            const el = document.createElement('span');
            el.setAttribute('class', 'word');
            el.innerHTML = words[i];
            this.textView.appendChild(el);
          }
        }

        validateInput(input) {
          // se a config manda 100% de match, returna true se input === palavra ativa
          // se config manda menos que 100%, calcula o percentual de match baseado na distancia levenshtein
          // independente da configuracao, emite uma estatistica de grau de acerto (isso faz parte dos resultados)
          function levenshtein(a, b) {
            if (a === '') return b.length;
            if (b === '') return a.length;
            if (a[0] === b[0]) {
              return levenshtein(a.substring(1), b.substring(1));
            } else {
              return 1 + Math.min(
                levenshtein(a.substring(1), b),
                levenshtein(a, b.substring(1)),
                levenshtein(a.substring(1), b.substring(1)),
              );
            }
          }

          const a = this.config.caseSensitive ? this.activeWord : this.activeWord.toLowerCase();
          const b = this.config.caseSensitive ? input : input.toLowerCase();
          const lev = levenshtein(a, b);
          const activeWordLen = this.activeWord.length;
          const similarity = (lev > activeWordLen) ? 0 : 1 - lev / activeWordLen;
          const accepted = similarity >= this.config.minimumAccuracy;
          // console.log({lev, activeWordLen, similarity, accepted, minimumAccuracy: this.config.minimumAccuracy});
          return {accepted, accuracy: similarity};
        }

        consumeActiveWord() {
          this.textView.removeChild(this.textView.firstChild);
          if (!this.textView.firstChild) {
            this.endGame();
          } else {
            this.textView.firstChild.classList.add('first');
            this.activeWord = this.textView.firstChild.innerHTML;
          }
        }

        endGame() {
          this.notifyListeners('outofwords');
        }

        admitInput(input) {
          const validation = this.validateInput(input);
          if (validation.accepted) {
            this.consumeActiveWord();
          }
          this.statusReporter.report(validation.accuracy);
          return validation;
        }

      }

      class InputController extends EventDriver {

        typedText;
        finishButton;

        constructor(typedText, finishButton) {
          super();
          this.typedText = typedText;
          this.finishButton = finishButton;
          this.disable();
          typedText.addEventListener('keydown', (e) => {
            if (e.keyCode !== 32 && e.keyCode !== 13) return;
            e.preventDefault();
            const input = typedText.value;
            typedText.value = '';
            this.notifyListeners('inputavailable', {input});
          })
          finishButton.addEventListener('click', (e) => {
            this.notifyListeners('endgamerequested');
          });
        }

        enable() {
          this.typedText.disabled = false;
          this.typedText.focus();
        }

        disable() {
          this.typedText.disabled = true;
        }

      }

      class TextService {

        TEXTS = [
          {
            key: 'lipsum1',
            name: 'Lorem Ipsum 1',
            text: 'Lorem ipsum dolor sit amet, consectetur adipiscing elit,' +
              'sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad' +
              'minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea' +
              'commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit' +
              'esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat' +
              'non proident, sunt in culpa qui officia deserunt mollit anim id est laborum'
          },
          {
            key: 'minilipsum1',
            name: 'Mini Lorem Ipsum 1',
            text: 'Lorem ipsum dolor sit amet',
          },
          {
            key: 'planetsmnem',
            name: 'Planetas - Mnemonico',
            text: 'Meu velho tio mandou junior saborear umas nove pizzas',
          },
          {
            key: 'frankbick',
            name: 'Frank Bickerton',
            text: 'Frank Bickerton spent most of the 1912 winter working to convert it to a sledge, fashioning brakes from a pair of geological drills and a steering system from the plane\'s landing gear. It was first tested on the 15th of November, 1912 and subsequently assisted in laying',
          },
          {
            key: 'escola-realengo',
            name: 'Escola Militar do Realengo',
            text: 'A Escola Militar do Realengo foi a instituição formadora de oficiais do Exército Brasileiro, de 1913 até sua transferência a Resende, em 1944, originando a Academia Militar das Agulhas Negras (AMAN). Ali iniciava a formação da elite militar, parte importante da consolidação do Estado republicano em sua época. Seus alunos, denominados cadetes após 1931, formavam-se como aspirantes-a-oficial, aptos a chefiar pelotões, e eram designados para os corpos de tropa. Mais acima na hierarquia militar, os oficiais prosseguiriam a instrução na Escola de Aperfeiçoamento de Oficiais e outras instituições. Cadetes da Aviação tinham apenas o início da formação no Realengo, concluindo-a na Escola de Aviação Militar, no Campo dos Afonsos.',
          },

        ];

        TEXT_NAMES = this.TEXTS.map(t => ({key: t.key, name: t.name}));

        getTextNames() {
          return this.TEXT_NAMES;
        }

        getTexts() {
          return this.TEXTS;
        }


        getTextByKey(textKey, options) {
          const {removePunctuation, removeSpecialChars} = options;
          let found = this.TEXTS.find(t => t.key === textKey);
          if (!found) return;
          if (removePunctuation) {
            const re = /[\.,;:?!]/g;
            found.text = found.text.replace(re, '');
          }
          if (removeSpecialChars) {
            found.text = found.text.replace(/[äâáàã]/g, 'a');
            found.text = found.text.replace(/[éê]/g, 'e');
            found.text = found.text.replace(/[í]/g, 'i');
            found.text = found.text.replace(/[óõ]/g, 'o');
            found.text = found.text.replace(/[ú]/g, 'u');
            found.text = found.text.replace(/[ç]/g, 'c');
          }
          return found.text;
        }

      }

      class ResultsPanelController {

        fullTypedText;
        wpmSpeedResult;
        avgAccuracyResult;

        constructor(fullTypedText, wpmSpeedResult, avgAccuracyResult) {
          this.fullTypedText = fullTypedText;
          this.wpmSpeedResult = wpmSpeedResult;
          this.avgAccuracyResult = avgAccuracyResult;
        }

        displayInput(input, validation) {
          const newWordSpan = document.createElement('span');
          newWordSpan.classList.add('typed-word');
          newWordSpan.innerHTML = input;
          if (!validation.accepted) {
            newWordSpan.classList.add('not-accepted');
          }
          if (validation.accuracy < 1) {
            newWordSpan.classList.add('inaccurate');
          }
          this.fullTypedText.appendChild(newWordSpan);
        }

        displayResults(results) {
          this.wpmSpeedResult.innerHTML = results.speedWpm;
          this.avgAccuracyResult.innerHTML = (Math.round(10000 * results.avgAccuracy) / 100) + '%';
        }

      }

      class StatusReporter {

        initDate;
        wordCount = 0;
        accuracies = [];

        reset() {
          this.initDate = undefined;
          this.wordCount = 0;
          this.accuracies = [];
        }

        start(initDate) {
          this.reset();
          this.initDate = !!initDate ? initDate : new Date();
        }

        report(accuracy) {
          //console.log('report, accuracy:', accuracy);
          this.wordCount++;
          this.accuracies.push(accuracy);
        }

        getStatus(refDate) {
          refDate = !!refDate ? refDate : new Date();
          return {
            speedWpm: Math.round(60000 * this.wordCount / (refDate.getTime() - this.initDate.getTime())),
            avgAccuracy: this.accuracies.reduce((a, c) => a + c, 0) / this.accuracies.length,
          };
        }

      }


      function byId(id) {
        return document.getElementById(id);
      }

      const modeSelect = byId('modeSelect');
      const textSelect = byId('textSelect');
      const minimumAccuracySelect = byId('minimumAccuracySelect');
      const chkCaseSensitive = byId('chkCaseSensitive');
      const chkPunctuation = byId('chkPunctuation');
      const chkRemoveSpecialChars = byId('chkRemoveSpecialChars');
      const gameStartButton = byId('gameStartButton');
      const textView = byId('textView');
      const typedText = byId('typedText');
      const finishButton = byId('finishButton');
      const fullTypedText = byId('fullTypedText');
      const wpmSpeedResult = byId('wpmSpeedResult');
      const avgAccuracyResult = byId('avgAccuracyResult');

      const textService = new TextService();

      const configurationController = new ConfigurationController(
        modeSelect, textSelect, minimumAccuracySelect,
        chkCaseSensitive, chkPunctuation, chkRemoveSpecialChars, gameStartButton,
        textService.getTextNames(),
      );
      const inputController = new InputController(typedText, finishButton);
      const statusReporter = new StatusReporter();
      const textBarController = new TextBarController(textView, statusReporter);
      const resultsPanelController = new ResultsPanelController(
        fullTypedText, wpmSpeedResult, avgAccuracyResult);

      // wirings

      // when the configuration is ready
      configurationController.addEventListener(
        'configurationready',
        (e) => {
          const config = e.config;
          console.log('configurationready', config);
          const textOptions = {
            removePunctuation: !config.requirePunctuation,
            removeSpecialChars: !!config.removeSpecialChars,
          };
          const {textKey} = e.config;
          const textContent = textService.getTextByKey(textKey, textOptions);
          textBarController.displayText(textContent, config);
          inputController.enable();
          textBarController.start();
        }
      );

      // when a word is typed and confirmed using RET or SPACE
      inputController.addEventListener(
        'inputavailable',
        (e) => {
          const input = e.input;
          const acceptance = textBarController.admitInput(input);
          resultsPanelController.displayInput(input, acceptance);
        }
      );

      function endgame(e) {
        console.log('game is about to finish', e);
      }

      inputController.addEventListener('endgamerequested', endgame);
      textBarController.addEventListener('outofwords', endgame);

      textBarController.addEventListener(
        'results',
        (e) => {
          // textBarController periodically makes results available. Results contain
          // average words-per-minute speed and average accuracy
          resultsPanelController.displayResults(e.results);
        },
      );

    </script>
</body>
</html>
