"use strict";

const EPSILON = 1e-6;

const BASE_BOID_POINTS = [0., 0., 0., 12., 20., 6];

// parameters of a simulation
// - list of boids and their following parameters:
//   - displacement x and y (normalized to [-0.5; 0.5])
//   - position x and y (also normalized, same interval)
// - canvas dimensions
// - avoidance radius (the distance a void will try to keep from others in order to
//   avoid collisions, also normalized, same interval aforementioned)
// - "followance" radius (the distance a boid will "see"; rules of Alignment and
//   Cohesion will be computed over boids within that radius, also normalized)
//
// =====================================================================================
// rules functions arguments
// - the simulation (so that rules functions can access all simulation parameters)
// - a reference individual boid
// - a "peer" boid (`tickSimulation` will iterate over the list of boids and call each
//   rule function for each of them)
// return values:
// - a flag indicating whether the rule was applied, considering the radiuses in the
//   simulation parameters and whether the boids involved are within the defined
//   radiuses
// - a suggested displacement (each rule will provide one and `tickSimulation`, in its
//   role as a coordination, will decide what to do with each one)

// RULE 1: SEPARATION
function rule1(sim, distance, referenceBoid, otherBoid) {
  if (distance > sim.avoidanceRadius)
    return {applied: 0, move: {dx: 0, dy: 0}};
  return {
    applied: 1,
    move: {
      dx: (referenceBoid.x - otherBoid.x) * sim.avoidanceFactor,
      dy: (referenceBoid.y - otherBoid.y) * sim.avoidanceFactor,
    },
  };
}

// RULE 2: ALIGNMENT
function rule2(sim, distance, referenceBoid, otherBoid) {
  if (distance > sim.followanceRadius)
    return {applied: 0, move: {dx: 0, dy: 0}};
  return {
    applied: 1,
    move: {
      dx: otherBoid.dx * sim.alignmentFactor,
      dy: otherBoid.dy * sim.alignmentFactor,
    }
  };
}

// RULE 3: COHESION
function rule3(sim, distance, referenceBoid, otherBoid) {
  if (distance > sim.followanceRadius)
    return {applied: 0, move: {dx: 0, dy: 0}};
  return {
    applied: 1,
    move: {
      dx: (otherBoid.x - referenceBoid.x) * sim.cohesionFactor,
      dy: (otherBoid.y - referenceBoid.y) * sim.cohesionFactor,
    },
  };
}

// RULE4: STAY WITHIN BOUNDS
function rule4(sim, distance, referenceBoid) {
  let applied = 0;
  let moveDx = 0;
  let moveDy = 0;
  const canvasW = sim.canvasDimensions.w;
  const canvasH = sim.canvasDimensions.h;
  if ((referenceBoid.x > (canvasW - sim.margin)) ||
    (referenceBoid.x < sim.margin)) {
    applied |= 1;
    moveDx = canvasW / 2 - referenceBoid.x;
  }
  if ((referenceBoid.y > (canvasH - sim.margin)) ||
    (referenceBoid.y < sim.margin)) {
    applied |= 1;
    moveDy = canvasH / 2 - referenceBoid.y;
  }
  return {
    applied,
    move: {
      dx: moveDx,
      dy: moveDy,
    }
  };
}


// =====================================================================================

// planMovements basic algorithm
// - for each referenceBoid
//   - for each otherBoid
//     - for each rule
//       - if not applicable, continue
//       - if applicable, accumulate the number of times/otherBoids the given rule was
//         applied over the given referenceBoid. This information will be used to compute
//         the average acceleration generated by the successive applications of the
//         given rule
//     - compute the average accelerations generated by each rule and prioritize them
function planMovements(sim) {
  for (const referenceBoid of sim.boids) {
    validateSimFinite(sim);
    let totalRule1Applied = 0;
    let totalRule2Applied = 0;
    let totalRule3Applied = 0;
    let totalRule1Move = {dx: 0, dy: 0};
    let totalRule2Move = {dx: 0, dy: 0};
    let totalRule3Move = {dx: 0, dy: 0};

    const previousDx = referenceBoid.dx;
    const previousDy = referenceBoid.dy;

    referenceBoid.color = undefined;

    const { applied: rule4Applied, move: rule4Move } = rule4(sim, undefined, referenceBoid);
    if (rule4Applied) {
      referenceBoid.dx = rule4Move.dx;
      referenceBoid.dy = rule4Move.dy;
      referenceBoid.color = 'green';
    } else {

      for (const otherBoid of sim.boids) {
        if (referenceBoid === otherBoid) continue;
        const distance = computeDistance(referenceBoid, otherBoid);
        const { applied: rule1Applied, move: rule1Move } = rule1(sim, distance, referenceBoid, otherBoid);
        const { applied: rule2Applied, move: rule2Move } = rule2(sim, distance, referenceBoid, otherBoid);
        const { applied: rule3Applied, move: rule3Move } = rule3(sim, distance, referenceBoid, otherBoid);
        totalRule1Applied += rule1Applied;
        totalRule2Applied += rule2Applied;
        totalRule3Applied += rule3Applied;
        totalRule1Move.dx += rule1Move.dx; totalRule1Move.dy += rule1Move.dy;
        totalRule2Move.dx += rule2Move.dx; totalRule2Move.dy += rule2Move.dy;
        totalRule3Move.dx += rule3Move.dx; totalRule3Move.dy += rule3Move.dy;
      }

      if (totalRule1Applied) {
        totalRule1Move.dx /= totalRule1Applied; totalRule1Move.dy /= totalRule1Applied;
      }
      if (totalRule2Applied) {
        totalRule2Move.dx /= totalRule2Applied; totalRule2Move.dy /= totalRule2Applied;
      }
      if (totalRule3Applied) {
        totalRule3Move.dx /= totalRule3Applied; totalRule3Move.dy /= totalRule3Applied;
      }

      referenceBoid.dx += totalRule1Move.dx;
      referenceBoid.dy += totalRule1Move.dy;
      referenceBoid.dx += totalRule2Move.dx; referenceBoid.dy += totalRule2Move.dy;
      referenceBoid.dx += totalRule3Move.dx; referenceBoid.dy += totalRule3Move.dy;
      referenceBoid.dx /= 3; referenceBoid.dy /= 3;

    }

    const velMagnitude = Math.sqrt(Math.pow(referenceBoid.dx, 2) + Math.pow(referenceBoid.dy, 2));
    if (velMagnitude < sim.minVelocityMagnitude) {
      const correction = sim.minVelocityMagnitude / velMagnitude;
      referenceBoid.dx *= correction;
      referenceBoid.dy *= correction;
    } else if (velMagnitude > sim.maxVelocityMagnitude) {
      const correction = sim.maxVelocityMagnitude / velMagnitude;
      referenceBoid.dx *= correction;
      referenceBoid.dy *= correction;
    }

    validateSimFinite(sim);

    const newVelMagnitude = computeVelocityMagnitude(referenceBoid.dx, referenceBoid.dy);
    const previousHeading = Math.atan2(previousDy, previousDx);
    const newHeading = Math.atan2(referenceBoid.dy, referenceBoid.dx);
    const relativeAngleChange = shortestAngleDiff(previousHeading, newHeading);
    const absoluteAngleChange = Math.abs(previousHeading - newHeading);
    //if ((relativeAngleChange - Math.PI) < EPSILON) {
    //  // in case of commanded 180 deg turns, always correct down. Afterwards, further
    //  // corrections will be downwards too. Without this fix, corrections will alternate
    //  // up and down in each iteration, making the boid to effectively fly in a single,
    //  // possibly wrong direction
    //  angleSignCorrection = -1;
    //} else {
    //  angleSignCorrection = relativeAngleChange == directAngleDiff(previousHeading, newHeading) ? 1 : -1;
    //}
    const angleSignCorrection = absoluteAngleChange > Math.PI ? -1 : 1;
    //const angleSignCorrection = -1;
    const effectiveAngleChange = angleSignCorrection * Math.min(relativeAngleChange, sim.maxAngleChange);
    if (relativeAngleChange > sim.maxAngleChange) {
      referenceBoid.dx = newVelMagnitude * Math.cos(previousHeading + effectiveAngleChange);
      referenceBoid.dy = newVelMagnitude * Math.sin(previousHeading + effectiveAngleChange);
    }

    //console.log(`dx = ${referenceBoid.dx}; dy = ${referenceBoid.dy}; ` +
    //  `relAngChange: ${radToDeg(relativeAngleChange)}; absAngChange: ${radToDeg(absoluteAngleChange)}; ` +
    //  `effAngChange: ${radToDeg(effectiveAngleChange)}`);

    if (referenceBoid.tag)
      console.table({
        dx: referenceBoid.dx,
        dy: referenceBoid.dy,
        relAngChange: radToDeg(relativeAngleChange),
        absAngChange: radToDeg(absoluteAngleChange),
        effAngChange: radToDeg(effectiveAngleChange),
      });

    validateSimFinite(sim);
  }
}

function validateSimFinite(sim) {
  for (const boid of sim.boids) {
    validateFinite(boid);
  }
}

function validateFinite(boid) {
  let invalid = false;
  invalid |= !Number.isFinite(boid.x);
  invalid |= !Number.isFinite(boid.y);
  invalid |= !Number.isFinite(boid.dx);
  invalid |= !Number.isFinite(boid.dy);
  if (invalid) { debugger; }
}

function shortestAngleDiff(a1, a2) {
  return Math.min(Math.abs(a1 - a2), 2 * Math.PI - Math.abs(a1 - a2));
}

function directAngleDiff(a1, a2) {
  return Math.abs(a1 - a2);
}

function performMovements(sim) {
  for (const boid of sim.boids) {
    boid.x += boid.dx;
    boid.y += boid.dy;
  }
}

function tickSimulation(sim) {
  planMovements(sim);
  performMovements(sim);
}

function computeDistance(boid1, boid2) {
  return Math.sqrt((boid2.x - boid1.x) ** 2 + (boid2.y - boid1.y) ** 2);
}

function validateBoids(sim) {
  if (sim.boids.length < 2) {
    throw new Error("The simulation doesn't meet the mininum amount of 2 boids");
  }
}

function computeVelocityMagnitude(dx, dy) {
  return Math.sqrt(dx * dx + dy * dy);
}

function drawBoid(sim, boid, canvas, ctx, fillColor='red') {
  const points = BASE_BOID_POINTS;
  const x = boid.x;
  const y = boid.y;
  const heading = Math.atan2(boid.dy, boid.dx);
  ctx.translate(x, y);
  ctx.rotate(heading);
  ctx.beginPath();
  ctx.moveTo(points[0], points[1]);
  ctx.lineTo(points[2], points[3]);
  ctx.lineTo(points[4], points[5]);
  ctx.lineTo(points[0], points[1]);
  ctx.rotate(-heading);
  //ctx.translate(-x, -y);
  ctx.strokeStyle = 'black';
  ctx.fillStyle = (!!boid['color']) ? boid['color'] : fillColor;
  ctx.lineWidth = 1;
  ctx.stroke();
  ctx.fill();
  // reset context translation?
  ctx.setTransform(1, 0, 0, 1, 0, 0);
}

function drawSimulation(sim, canvas, ctx, preserve=false, fillColor='red') {
  if (!preserve) ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (const boid of sim.boids) {
    drawBoid(sim, boid, canvas, ctx, fillColor);
  }
}

function printBoids(sim, label) {
  console.log(label);
  for (let i = 0; i < sim.boids.length; i++) {
    console.log(`Boid ${i}: x=${sim.boids[i].x}, y=${sim.boids[i].y}, dx=${sim.boids[i].dx}, dy=${sim.boids[i].dy}`);
  }
}

function animateSimulation(sim, canvas, ctx) {
  tickSimulation(sim);
  drawSimulation(sim, canvas, ctx);
  window.setTimeout(() => {
    window.requestAnimationFrame(() => animateSimulation(sim, canvas, ctx));
  }, 200);
}

function radToDeg(angRad) {
  return angRad * 180 / Math.PI;
}

function generateRandomBoids(count, speed, canvasW, canvasH) {
  let boids = new Array(count);
  for (let i = 0; i < count; i++) {
    const heading = Math.random() * 2 * Math.PI;
    boids[i] = {
      x: Math.random() * canvasW,
      y: Math.random() * canvasH,
      dx: speed * Math.cos(heading),
      dy: speed * Math.sin(heading),
      color: 'red',
      tag: i === 0,
    };
  }
  return boids;
}

document.addEventListener('DOMContentLoaded', () => {
  const canvas = document.getElementById("boidsCanvas");
  const sim = {
    boids: generateRandomBoids(2, 10, canvas.width, canvas.height),
    canvasDimensions: {w: canvas.width, h: canvas.height},
    avoidanceRadius: 40,
    followanceRadius: 400,
    maxVelocityMagnitude: 30,
    minVelocityMagnitude: 10,
    maxAngleChange: Math.PI / 2,
    avoidanceFactor: 1.,
    cohesionFactor: 2.,
    alignmentFactor: 0.5,
    margin: 80,
  };
  console.log({sim});
  const ctx = canvas.getContext("2d");
  animateSimulation(sim, canvas, ctx);
});
