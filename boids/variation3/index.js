"use strict";

const EPSILON = 1e-6;

const BASE_BOID_POINTS = [0., 0., 0., 0.025, 0.04, 0.0125];

(function() {

  // parameters of a simulation
  // - list of boids and their following parameters:
  //   - displacement x and y (normalized to [-0.5; 0.5])
  //   - position x and y (also normalized, same interval)
  // - canvas dimensions
  // - avoidance radius (the distance a void will try to keep from others in order to
  //   avoid collisions, also normalized, same interval aforementioned)
  // - "followance" radius (the distance a boid will "see"; rules of Alignment and
  //   Cohesion will be computed over boids within that radius, also normalized)
  const sim1 = {
    boids: [
      { x: 0.5,   y: 0.5,   dx: 0.00, dy: 0.001 },
      { x: 0.6, y: 0.6, dx: 0.001, dy: 0.001 },
      { x: 0.7, y: 0.7, dx: 0.001, dy: 0.00 }
    ],
    canvasDimensions: {x: 500, y: 500},
    avoidanceRadius: 0.001,
    followanceRadius: 0.5,
    maxVelocityMagnitude: 0.01,
    minVelocityMagnitude: 0.002,
    maxAngleChange: Math.PI / 16,
    avoidanceFactor: 0.05,
    cohesionFactor: 0.05,
    alignmentFactor: 0.01,
    marginPx: 50,
  };

  // =====================================================================================
  // rules functions arguments
  // - the simulation (so that rules functions can access all simulation parameters)
  // - a reference individual boid
  // - a "peer" boid (`tickSimulation` will iterate over the list of boids and call each
  //   rule function for each of them)
  // return values:
  // - a flag indicating whether the rule was applied, considering the radiuses in the
  //   simulation parameters and whether the boids involved are within the defined
  //   radiuses
  // - a suggested displacement (each rule will provide one and `tickSimulation`, in its
  //   role as a coordination, will decide what to do with each one)

  // RULE 1: SEPARATION
  function rule1(sim, distance, referenceBoid, otherBoid) {
    if (distance > sim.avoidanceRadius)
      return {applied: 0, move: {dx: 0, dy: 0}};
    return {
      applied: 1,
      move: {
        dx: (referenceBoid.x - otherBoid.x) * sim.avoidanceFactor,
        dy: (referenceBoid.y - otherBoid.y) * sim.avoidanceFactor,
      },
    };
  }

  // RULE 2: ALIGNMENT
  function rule2(sim, distance, referenceBoid, otherBoid) {
    if (distance > sim.followanceRadius)
      return {applied: 0, move: {dx: 0, dy: 0}};
    return {
      applied: 1,
      move: {
        dx: otherBoid.dx * sim.alignmentFactor,
        dy: otherBoid.dy * sim.alignmentFactor,
      }
    };
  }

  // RULE 3: COHESION
  function rule3(sim, distance, referenceBoid, otherBoid) {
    if (distance > sim.followanceRadius)
      return {applied: 0, move: {dx: 0, dy: 0}};
    return {
      applied: 1,
      move: {
        dx: (otherBoid.x - referenceBoid.x) * sim.cohesionFactor,
        dy: (otherBoid.y - referenceBoid.y) * sim.cohesionFactor,
      },
    };
  }

  // RULE4: STAY WITHIN BOUNDS
  function rule4(sim, distance, referenceBoid) {
    let applied = false;
    let moveDx = 0;
    let moveDy = 0;
    const canvasW = sim.canvasDimensions.x;
    const canvasH = sim.canvasDimensions.y;
    if (referenceBoid.x * canvasW > canvasW - sim.marginPx ||
        referenceBoid.x * canvasW < sim.marginPx ) {
      applied |= true;
      moveDx = referenceBoid.dx * -1;
    }
    if (referenceBoid.y * canvasH > canvasH - sim.marginPx ||
        referenceBoid.y * canvasH < sim.marginPx ) {
      applied |= true;
      moveDy = referenceBoid.dy * -1;
    }
    return {
      applied: applied ? 1 : 0,
      move: {
        dx: moveDx,
        dy: moveDy,
      }
    };
  }


  // =====================================================================================

  // planMovements basic algorithm
  // - for each referenceBoid
  //   - for each otherBoid
  //     - for each rule
  //       - if not applicable, continue
  //       - if applicable, accumulate the number of times/otherBoids the given rule was
  //         applied over the given referenceBoid. This information will be used to compute
  //         the average acceleration generated by the successive applications of the
  //         given rule
  //     - compute the average accelerations generated by each rule and prioritize them
  function planMovements(sim) {
    for (const referenceBoid of sim.boids) {
      validateSimFinite(sim);
      let totalRule1Applied = 0;
      let totalRule2Applied = 0;
      let totalRule3Applied = 0;
      let totalRule1Move = {dx: 0, dy: 0};
      let totalRule2Move = {dx: 0, dy: 0};
      let totalRule3Move = {dx: 0, dy: 0};

      for (const otherBoid of sim.boids) {
        if (referenceBoid === otherBoid) continue;
        const distance = computeDistance(referenceBoid, otherBoid);
        const { applied: rule1Applied, move: rule1Move } = rule1(sim, distance, referenceBoid, otherBoid);
        const { applied: rule2Applied, move: rule2Move } = rule2(sim, distance, referenceBoid, otherBoid);
        const { applied: rule3Applied, move: rule3Move } = rule3(sim, distance, referenceBoid, otherBoid);
        totalRule1Applied += rule1Applied;
        totalRule2Applied += rule2Applied;
        totalRule3Applied += rule3Applied;
        totalRule1Move.dx += rule1Move.dx; totalRule1Move.dy += rule1Move.dy;
        totalRule2Move.dx += rule2Move.dx; totalRule2Move.dy += rule2Move.dy;
        totalRule3Move.dx += rule3Move.dx; totalRule3Move.dy += rule3Move.dy;
      }

      if (totalRule1Applied) {
        totalRule1Move.dx /= totalRule1Applied; totalRule1Move.dy /= totalRule1Applied;
      }
      if (totalRule2Applied) {
        totalRule2Move.dx /= totalRule2Applied; totalRule2Move.dy /= totalRule2Applied;
      }
      if (totalRule3Applied) {
        totalRule3Move.dx /= totalRule3Applied; totalRule3Move.dy /= totalRule3Applied;
      }

      const previousDx = referenceBoid.dx;
      const previousDy = referenceBoid.dy;

      referenceBoid.dx += totalRule1Move.dx;
      referenceBoid.dy += totalRule1Move.dy;
      referenceBoid.dx += totalRule2Move.dx; referenceBoid.dy += totalRule2Move.dy;
      referenceBoid.dx += totalRule3Move.dx; referenceBoid.dy += totalRule3Move.dy;
      referenceBoid.dx /= 2; referenceBoid.dy /= 2;

      const velMagnitude = Math.sqrt(Math.pow(referenceBoid.dx, 2) + Math.pow(referenceBoid.dy, 2));
      if (velMagnitude < sim.minVelocityMagnitude) {
        const correction = sim.minVelocityMagnitude / velMagnitude;
        referenceBoid.dx *= correction;
        referenceBoid.dy *= correction;
      } else if (velMagnitude > sim.maxVelocityMagnitude) {
        const correction = sim.maxVelocityMagnitude / velMagnitude;
        referenceBoid.dx *= correction;
        referenceBoid.dy *= correction;
      }

      validateSimFinite(sim);

      const { applied: rule4Applied, move: rule4Move } = rule4(sim, undefined, referenceBoid);
      if (rule4Applied) {
        referenceBoid.dx = rule4Move.dx;
        referenceBoid.dy = rule4Move.dy;
      }

      const newVelMagnitude = computeVelocityMagnitude(referenceBoid.dx, referenceBoid.dy);
      const previousHeading = Math.atan2(previousDy, previousDx);
      const newHeading = Math.atan2(referenceBoid.dy, referenceBoid.dx);
      const angleChange = shortestAngleDiff(previousHeading, newHeading);
      const angleSignCorrection = angleChange == directAngleDiff(previousHeading, newHeading) ? 1 : -1;
      if (angleChange > sim.maxAngleChange) {
        //TODO determine the direction (cw or ccw) of the change
        referenceBoid.dx = newVelMagnitude * Math.cos(previousHeading + angleSignCorrection * sim.maxAngleChange);
        referenceBoid.dy = newVelMagnitude * Math.sin(previousHeading + angleSignCorrection * sim.maxAngleChange);
      }


      validateSimFinite(sim);
    }
  }

  function validateSimFinite(sim) {
    for (const boid of sim.boids) {
      validateFinite(boid);
    }
  }

  function validateFinite(boid) {
    let invalid = false;
    invalid |= !Number.isFinite(boid.x);
    invalid |= !Number.isFinite(boid.y);
    invalid |= !Number.isFinite(boid.dx);
    invalid |= !Number.isFinite(boid.dy);
    if (invalid) { debugger; }
  }

  function shortestAngleDiff(a1, a2) {
    return Math.min(Math.abs(a1 - a2), 2 * Math.PI - Math.abs(a1 - a2));
  }

  function directAngleDiff(a1, a2) {
    return Math.abs(a1 - a2);
  }

  function performMovements(sim) {
    for (const boid of sim.boids) {
      boid.x += boid.dx;
      boid.y += boid.dy;
    }
  }

  function tickSimulation(sim) {
    planMovements(sim);
    performMovements(sim);
  }

  function computeDistance(boid1, boid2) {
    return Math.sqrt((boid2.x - boid1.x) ** 2 + (boid2.y - boid1.y) ** 2);
  }

  function validateBoids(sim) {
    if (sim.boids.length < 2) {
      throw new Error("The simulation doesn't meet the mininum amount of 2 boids");
    }
  }

  function computeVelocityMagnitude(dx, dy) {
    return Math.sqrt(dx * dx + dy * dy);
  }

  function drawBoid(sim, boid, canvas, ctx, fillColor='red') {
    const points = BASE_BOID_POINTS.map(p => p * 500);
    const x = boid.x * canvas.width;
    const y = boid.y * canvas.height;
    const heading = Math.atan2(boid.dy, boid.dx);
    ctx.translate(x, y);
    ctx.rotate(heading);
    ctx.beginPath();
    ctx.moveTo(points[0], points[1]);
    ctx.lineTo(points[2], points[3]);
    ctx.lineTo(points[4], points[5]);
    ctx.lineTo(points[0], points[1]);
    ctx.rotate(-heading);
    //ctx.translate(-x, -y);
    ctx.strokeStyle = 'black';
    ctx.fillStyle = fillColor;
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.fill();
    // reset context translation?
    ctx.setTransform(1, 0, 0, 1, 0, 0);
  }

  function drawSimulation(sim, canvas, ctx, preserve=false, fillColor='red') {
    if (!preserve) ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (const boid of sim.boids) {
      drawBoid(sim, boid, canvas, ctx, fillColor);
    }
  }

  function testDraw() {
    const canvas = document.getElementById("boidsCanvas");
    const ctx = canvas.getContext("2d");
    for (const boid of sim1.boids) {
      drawBoid(sim1, boid, canvas, ctx);
    }
    //for (const boid of sim1.boids) {
    //  drawBoid(sim1, boid, canvas, ctx);
    //}
  }

  function runTests(sim) {

    const distanceSuite = new TestSuite('Distance Suite');
    distanceSuite.addTest({
      testFn: () => {
        const boid1 = {x: 0., y: 0., dx: 0., dy: 0.};
        const boid2 = {x: 0.05, y: 0., dx: 0., dy: 0.};
        const dist = computeDistance(boid1, boid2);
        return (0.005 - dist) < EPSILON;
      },
      description: 'Compute distance between two boids on same Y axis',
    });
    distanceSuite.addTest({
      testFn: () => {
        const boid1 = {x: 0., y: 0., dx: 0., dy: 0.};
        const boid2 = {x: 0., y: 0.05, dx: 0., dy: 0.};
        const dist = computeDistance(boid1, boid2);
        return (0.005 - dist) < EPSILON;
      },
      description: 'Compute distance between two boids on same X axis',
    });
    distanceSuite.addTest({
      testFn: () => {
        const boid1 = {x: 0., y: 0., dx: 0., dy: 0.};
        const boid2 = {x: 0.1, y: 0.1, dx: 0., dy: 0.};
        const dist = computeDistance(boid1, boid2);
        return (0.14141 - dist) < EPSILON;
      },
      description: 'Compute distance between two boids at a 45deg angle each other',
    });
    distanceSuite.runTests();

    const rule1Suite = new TestSuite('Rule 1 Suite');
    rule1Suite.addTest({
      testFn: () => {
        const sim = {avoidanceRadius: 0.1};
        const boid1 = {x: 0., y: 0., dx: 0., dy: 0.};
        const boid2 = {x: 0.05, y: 0., dx: 0., dy: 0.};
        const dist = computeDistance(boid1, boid2);
        const rule1Result = rule1(sim, dist, boid1, boid2);
        const rule1ResultInvertedBoids = rule1(sim, dist, boid2, boid1);
        return (rule1Result.move.dx == -0.05) && (rule1ResultInvertedBoids.move.dx == 0.05);
      },
      description: 'Rule 1, both at Y axis, within avoidance range',
    });
    rule1Suite.addTest({
      testFn: () => {
        const sim = {avoidanceRadius: 0.1};
        const boid1 = {x: 0., y: 0., dx: 0., dy: 0.};
        const boid2 = {x: 0.1001, y: 0., dx: 0., dy: 0.};
        const dist = computeDistance(boid1, boid2);
        const rule1Result = rule1(sim, dist, boid1, boid2);
        const rule1ResultInvertedBoids = rule1(sim, dist, boid2, boid1);
        return (rule1Result.move.dx == 0.) && (rule1ResultInvertedBoids.move.dx == 0.);
      },
      description: 'Rule 1, both at Y axis, OUT avoidance range',
    });
    rule1Suite.addTest({
      testFn: () => {
        const sim = {avoidanceRadius: 0.1};
        const boid1 = {x: 0.05, y: 0., dx: 0., dy: 0.};
        const boid2 = {x: 0.15,  y: 0., dx: 0., dy: 0.};
        const boidRef = {x: 0.1, y: 0., dx: 0., dy: 0.};
        const distTo1 = computeDistance(boidRef, boid1);
        const distTo2 = computeDistance(boidRef, boid2);
        const rule1ToBoid1 = rule1(sim, distTo1, boidRef, boid1);
        const rule1ToBoid2 = rule1(sim, distTo2, boidRef, boid2);
        const totalBoidRefDx = (rule1ToBoid1.move.dx + rule1ToBoid2.move.dx) / 2;
        return totalBoidRefDx < EPSILON;
      },
      description: 'Rule 1, stationary when at same distance to two opposite boids',
    });
    rule1Suite.runTests();

    const speedSuite = new TestSuite('Distance Suite');
    speedSuite.addTest({
      testFn: () => {
        const sim1 = {
          boids: [
            {x: 0.05, y: 0.15, dx: 0., dy: 0.},
            {x: 0.25,  y: 0., dx: 0., dy: 0.},
          ],
          canvasDimensions: {x: 500, y: 500},
          avoidanceRadius: 0.1,
          followanceRadius: 0.5,
          maxVelocityMagnitude: 0.01,
          minVelocityMagnitude: 0.002,
        };
        const canvas = document.getElementById('boidsCanvas');
        const ctx = canvas.getContext('2d');
        printBoids(sim1, 'Before');
        drawSimulation(sim1, canvas, ctx, true, 'red');
        planMovements(sim1);
        performMovements(sim1);
        printBoids(sim1, 'After');
        drawSimulation(sim1, canvas, ctx, true, 'green');
      },
      description: 'Resulting speed is within limits',
    });
    //speedSuite.runTests();

    const angleSuite = new TestSuite('Max Change in Angle Suite');
    angleSuite.addTest({
      testFn: () => {
        const sim1 = {
          boids: [
            {x: 0.05, y: 0., dx: 0.01, dy: 0.},
            {x: 0.15,  y: 0.2, dx: -0.01, dy: 0.},
          ],
          canvasDimensions: {x: 500, y: 500},
          avoidanceRadius: 0.1,
          followanceRadius: 0.5,
          maxVelocityMagnitude: 0.01,
          minVelocityMagnitude: 0.002,
          maxAngleChange: Math.PI / 8,
        };
        const canvas = document.getElementById('boidsCanvas');
        const ctx = canvas.getContext('2d');
        printBoids(sim1, 'Before');
        drawSimulation(sim1, canvas, ctx, true, 'red');
        planMovements(sim1);
        performMovements(sim1);
        printBoids(sim1, 'After');
        drawSimulation(sim1, canvas, ctx, true, 'green');
      },
      description: 'Max Change in Angle is respected between iterations',
    });
    angleSuite.runTests();
  }

  function printBoids(sim, label) {
    console.log(label);
    for (let i = 0; i < sim.boids.length; i++) {
      console.log(`Boid ${i}: x=${sim.boids[i].x}, y=${sim.boids[i].y}, dx=${sim.boids[i].dx}, dy=${sim.boids[i].dy}`);
    }
  }

  //testDraw();
  //runTests();

  function animateSimulation(sim, canvas, ctx) {
    tickSimulation(sim);
    drawSimulation(sim, canvas, ctx);
    window.setTimeout(() => {
      window.requestAnimationFrame(() => animateSimulation(sim, canvas, ctx));
    }, 100);
  }

  function generateRandomBoids(count) {
    let boids = new Array(count);
    for (let i = 0; i < count; i++) {
      boids[i] = {x: Math.random() / 2, y: Math.random() / 2, dx: 0., dy: 0.};
    }
    return boids;
  }

  document.addEventListener('DOMContentLoaded', () => {
    const sim = {
      boids: generateRandomBoids(10),
      canvasDimensions: {x: 500, y: 500},
      avoidanceRadius: 0.01,
      followanceRadius: 0.15,
      maxVelocityMagnitude: 0.04,
      minVelocityMagnitude: 0.01,
      maxAngleChange: Math.PI / 8,
      avoidanceFactor: 0.05,
      cohesionFactor: 0.8,
      alignmentFactor: 0.0,
      marginPx: 50,
    };
    const canvas = document.getElementById("boidsCanvas");
    const ctx = canvas.getContext("2d");
    animateSimulation(sim, canvas, ctx);
  });

})();
